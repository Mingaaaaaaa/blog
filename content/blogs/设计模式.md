# 订阅与发布/观察者模式
前者比后者多了一个 管理员

# 观察者模式
```javascript
class Observer {

  constructor(name, subject) {
    this.name = name;
    if (subject) {
      subject.addObserver(this);
    }
  }

  notified(message) {
    console.log(this.name, 'got message', message);
  }
}
```

```javascript
class Subject {

  constructor() {
    this.observerList = [];
  }

  addObserver(observer) {
    this.observerList.push(observer);
  }

  removeObserver(observer) {
    const index = this.observerList.findIndex(o => o.name === observer.name);
    this.observerList.splice(index, 1);
  }

  notifyObservers(message) {
    const observers = this.observeList;
    observers.forEach(observer => observer.notified(message));
  }

}
```

# 装饰器模式
扩展对象

装饰器模式，又名装饰者模式。它的定义是“**在不改变原对象的基础上，通过对其进行包装拓展，使得原有对象可以动态具有更多功能，从而满足用户的更复杂需求**”。

# 工厂模式
构造对象只需要调用函数即可，根据不用的输入返回不同的实例，一般用来创建同一类对象，它的**主要思想就是将对象的创建与对象的实现分离**。

```javascript
// 工厂方法
function Factory(career){
  if(this instanceof Factory){
    var a = new this[career]();
    return a;
  }else{
    return new Factory(career);
  }
}
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype={
  'coder': function(){
    this.careerName = '程序员'
    this.work = ['写代码', '修Bug'] 
  },
  'hr': function(){
    this.careerName = 'HR'
    this.work = ['招聘', '员工信息管理']
  },
  'driver': function () {
    this.careerName = '司机'
    this.work = ['开车']
  },
  'boss': function(){
    this.careerName = '老板'
    this.work = ['喝茶', '开会', '审批文件']
  }
}
let coder = new Factory('coder')
console.log(coder)
let hr = new Factory('hr')
console.log(hr)
```

# 单例模式
**保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。**

```javascript
function SingleTon(name){
    this.name = name;
    this.instance = null;
}

SingleTon.getName = (){
  retur this.name
}
SingleTon.getInstance =(name){
  return  this.instance || ( this.instance = new SingleTon(name))
}

// 获取对象1
const a = Singleton.getInstance('a');
// 获取对象2
const b = Singleton.getInstance('b');
// 进行比较
console.log(a === b);

---------------------
// 构造函数形式  闭包
function creatSingleTon(name){
  this.name = name;
}
  
function SingleTon = (function (){
      var instance = null
      return function (name){
            return instanle || (instance = new creatSingleTon(name)         
      }
})()

// 创建实例对象1
const a = new Singleton('a');
// 创建实例对象2
const b = new Singleton('b');

console.log(a===b); // true
```



